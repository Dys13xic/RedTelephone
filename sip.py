# The user agent client (UAC) sends SIP requests. The user agent server (UAS) receives requests and returns a SIP response. Unlike other network protocols that
# fix the roles of client and server, e.g., in HTTP, in which a web browser only acts as a client, and never as a server, 
# SIP requires both peers to implement both roles


import socket
import threading
import time
import random
import hashlib
import queue

PORT = 5060
READ_SIZE = 1024
SOCKET_TIMEOUT = 1

class UDPTransport:

    def __init__(self, port):
        self.port = port

    def listener(self, recvQueue, stopThread):
        sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        sock.settimeout(SOCKET_TIMEOUT)
        sock.bind("", self.port)

        while(stopThread.isset() == False):
            try:
                data, (srcAddress, srcPort) = sock.recvfrom(READ_SIZE)
                # TODO implement functionality to ensure whole message content received.
                recvQueue.put((srcAddress, srcPort, data))
            except socket.timeout:
                continue

        sock.close()

    def sender(self, sendQueue, stopThread):
        sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        while(stopThread.isset() == False):
            try:
                (targetAddress, targetPort, data) = sendQueue.get(timeout=1)
                bytesSent = sock.sendto(data), (targetAddress, targetPort)
                # TODO confirm that bytes sent matches data size
            except queue.Empty:
                continue

class Transport:


# LOCAL_IP, LOCAL_PORT = "192.168.2.12", 5060
# REMOTE_IP, REMOTE_PORT = "192.168.2.20", 5060

# method = "INVITE"
# requestLine = "{} sip:{}:{} SIP/2.0\r\n".format(method, REMOTE_IP, REMOTE_PORT)

# # TODO generate fromTag
# fromTag = hex(int(random.getrandbits(32)))[2:]

# # toTag generated by response
# toTag = ""

# callID = hex(time.time_ns())[2:] + hex(int(random.getrandbits(32)))[2:] + "@cleckie.com"

# sequence = 1

# headers = {
#     "Via": "SIP/2.0/UDP {}:{}".format(LOCAL_IP, LOCAL_PORT),
#     "From": "<sip:IPCall@{}:{}>".format(LOCAL_IP, LOCAL_PORT),
#     "To": "<sip:{}:{}>".format(REMOTE_IP, REMOTE_PORT),
#     "Call-ID": "{}".format(callID),
#     "CSeq": "{} {}".format(sequence, method),
#     "Max-Forwards": "70"
# }

# # TODO include Request-URI of the request received (before translation) in hash
# branch = "z9hG4bK" + hashlib.md5((toTag + fromTag + headers["Call-ID"] + headers["Via"] + str(sequence)).encode()).hexdigest()

# # Add branch and from tag
# headers["Via"] = headers["Via"] + ";branch=" + branch
# headers["From"] = headers["From"] + ";tag=" + fromTag


# request = requestLine

# for key in headers.keys():
#     request += key + ": " + headers[key] + "\r\n"

# print(request)

# clientSock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

# clientSock.bind(("", LOCAL_PORT))

# clientSock.sendto(bytes(request + "\n", "utf-8"), (REMOTE_IP, REMOTE_PORT))

# while True:
#     time.sleep(1) 
#     received, address = clientSock.recvfrom(4096)
#     print(received)